<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Concentration Predictor</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" />
    <style>
        .container {
            max-width: 800px;
            margin: 20px auto;
            padding: 0 15px;
        }
        #plot {
            width: 100%;
            height: 400px;
        }
        .card {
            margin-bottom: 1.5rem;
            border-radius: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .form-control {
            border-radius: 8px;
            padding: 12px;
        }
        .btn {
            border-radius: 8px;
            padding: 12px 20px;
            width: 100%;
        }
        .card-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 1rem;
        }
        @media (max-width: 768px) {
            #plot {
                height: 300px;
            }
            .card-title {
                font-size: 1.1rem;
            }
            .card-body {
                padding: 1rem;
            }
            .form-control {
                font-size: 16px;
                margin-bottom: 0.5rem;
            }
            .btn {
                font-size: 14px;
            }
            h1 {
                font-size: 1.5rem;
                margin-bottom: 1.5rem;
            }
            .text-muted {
                font-size: 0.85rem;
            }
        }
        #predictionResult {
            word-break: break-word;
        }
        .input-group {
            gap: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="mb-3 text-center">Concentration Predictor</h1>

        <div class="card mb-3">
            <div class="card-body">
                <h5 class="card-title">üìÅ Upload Data</h5>
                <input type="file" id="dataFile" class="form-control" accept=".xlsx, .csv" />
                <small class="form-text text-muted mt-2 d-block">
                    Supported formats: Excel (.xlsx) or CSV (.csv). First column: greyscale values, second column: concentration.
                </small>
            </div>
        </div>

        <div class="card mb-3">
            <div class="card-body">
                <h5 class="card-title">üîÆ Prediction</h5>
                <div class="input-group flex-column flex-md-row">
                    <input type="number" id="greyscaleInput" class="form-control mb-2 mb-md-0" 
                           placeholder="Enter greyscale value" step="any" inputmode="decimal" />
                    <button onclick="predict()" class="btn btn-primary">
                        Predict Concentration
                    </button>
                </div>
                <div id="predictionResult" class="mt-3"></div>
            </div>
        </div>

        <div class="card">
            <div class="card-body">
                <h5 class="card-title">üìà Regression Plot</h5>
                <div id="plot"></div>
            </div>
        </div>
    </div>

    <script>
        let regressionModel = { slope: 0, intercept: 0 };
        let dataPoints = [];
        let predictedPoint = null;

        document.getElementById("dataFile").addEventListener("change", function (e) {
            const file = e.target.files[0];
            const reader = new FileReader();

            reader.onload = function (e) {
                const fileExtension = file.name.split(".").pop().toLowerCase();
                if (fileExtension === "xlsx") {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: "array" });
                    const worksheet = workbook.Sheets[workbook.SheetNames[0]];
                    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
                    processData(jsonData);
                } else if (fileExtension === "csv") {
                    const csvData = e.target.result;
                    const jsonData = parseCSV(csvData);
                    processData(jsonData);
                } else {
                    alert("Unsupported file type. Please upload an Excel (.xlsx) or CSV (.csv) file.");
                }
            };

            if (file) {
                file.name.split(".").pop().toLowerCase() === "xlsx" ? reader.readAsArrayBuffer(file) : reader.readAsText(file);
            }
        });

        function parseCSV(csvData) {
            const lines = csvData.split("\n");
            const result = [];
            for (let i = 1; i < lines.length; i++) {
                const currentline = lines[i].split(",");
                if (currentline[0]) result.push(currentline);
            }
            return result;
        }

        function processData(jsonData) {
            dataPoints = jsonData.slice(1).map(row => ({
                x: parseFloat(row[0]),
                y: parseFloat(row[1])
            })).filter(p => !isNaN(p.x) && !isNaN(p.y));

            predictedPoint = null;
            calculateRegression();
            plotData();
        }

        function calculateRegression() {
            const x = dataPoints.map(p => p.x);
            const y = dataPoints.map(p => p.y);
            const n = x.length;

            const sumX = x.reduce((a, b) => a + b, 0);
            const sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = x.reduce((a, b, i) => a + b * y[i], 0);
            const sumX2 = x.reduce((a, b) => a + b * b, 0);

            regressionModel.slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            regressionModel.intercept = (sumY - regressionModel.slope * sumX) / n;
        }

        function plotData() {
            const x = dataPoints.map(p => p.x);
            const y = dataPoints.map(p => p.y);
            const xRange = [Math.min(...x), Math.max(...x)];
            const yRange = [
                regressionModel.slope * xRange[0] + regressionModel.intercept,
                regressionModel.slope * xRange[1] + regressionModel.intercept
            ];

            const traces = [{
                x: x,
                y: y,
                mode: "markers",
                type: "scatter",
                name: "Data Points",
                marker: { color: "blue" }
            }, {
                x: xRange,
                y: yRange,
                mode: "lines",
                type: "scatter",
                name: "Regression Line",
                line: { color: "green" }
            }];

            if (predictedPoint) {
                traces.push({
                    x: [predictedPoint.x],
                    y: [predictedPoint.y],
                    mode: "markers",
                    type: "scatter",
                    name: "Predicted Point",
                    marker: { color: "red", size: 12, symbol: "star" }
                });
            }

            const layout = {
                title: "Regression Analysis",
                xaxis: { title: "Greyscale Value" },
                yaxis: { title: "Concentration" },
                margin: { t: 40, l: 50, r: 20, b: 50 },
                autosize: true,
                responsive: true
            };

            Plotly.newPlot("plot", traces, layout, { responsive: true });
        }

        function predict() {
            const input = parseFloat(document.getElementById("greyscaleInput").value);
            const resultDiv = document.getElementById("predictionResult");
            
            if (isNaN(input)) {
                resultDiv.innerHTML = '<div class="alert alert-danger">Please enter a valid number</div>';
                return;
            }

            const prediction = regressionModel.slope * input + regressionModel.intercept;
            predictedPoint = { x: input, y: prediction };

            resultDiv.innerHTML = `
                <div class="alert alert-success">
                    Predicted concentration for greyscale value ${input.toFixed(2)}:
                    <strong>${prediction.toFixed(4)}</strong>
                </div>
            `;

            plotData();
        }
    </script>
</body>
</html>
